<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mataya-Taya Game with Sprites - 1 Player</title>
<link rel="icon" type="image/png" href="favicon.png">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
body {
  margin: 0; padding: 0;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
  font-family: 'Press Start 2P', cursive;
}
canvas {
  width: 65em;
  height: 40em;
  border: 4px solid #ffcc00;
  image-rendering: pixelated;
  background: url("place.jpg") no-repeat center center;
  background-size: cover;
}
#countdown {
  position: absolute;
  top: 40%;
  font-size: 48px;
  color: #ffcc00;
  text-shadow: 2px 2px 4px #000;
  animation: pop 1s ease infinite;
}
@keyframes pop {
  from { transform: scale(1); opacity: 1; }
  to { transform: scale(1.5); opacity: 0.6; }
}
.retroModal {
  position: fixed; top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  visibility: hidden;
  z-index: 10;
}
.retroContent {
  position: relative;
  background: #000;
  padding: 40px;
  border: 6px solid #ffcc00;
  text-align: center;
  box-shadow: 0 0 15px #ffcc00, inset 0 0 8px #663300;
  color: #ffcc00;
  font-family: 'Press Start 2P', cursive;
}
.retroContent::after {
  content: "";
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: repeating-linear-gradient(
    transparent 0px,
    rgba(255,255,255,0.05) 2px,
    transparent 4px
  );
  pointer-events: none;
}
.retroContent h1 {
  font-size: 28px;
  margin-bottom: 25px;
  color: #ff4444;
  text-shadow: 2px 2px #000, -2px -2px #000, 0 0 10px #ff0000;
}
.retroBtn {
  display: block;
  margin: 15px auto;
  padding: 15px 25px;
  font-size: 14px;
  background: #111;
  color: #ffcc00;
  border: 4px solid #ffcc00;
  cursor: pointer;
  border-radius: 0;
  text-transform: uppercase;
  font-family: 'Press Start 2P', cursive;
  transition: all 0.2s ease-in-out;
}
.retroBtn:hover {
  background: #ffcc00;
  color: #000;
  box-shadow: 0 0 10px #ffcc00;
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="900" height="500"></canvas>
<div id="countdown"></div>

<!-- Game Over Modal -->
<div id="gameOverModal" class="retroModal">
  <div id="gameOverContent" class="retroContent">
    <h1>GAME OVER!</h1>
    <button id="restartBtn" class="retroBtn">START AGAIN</button>
  </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="retroModal">
  <div class="retroContent">
    <h1>SETTINGS</h1>
    <button id="quitBtn" class="retroBtn">QUIT</button>
    <button id="changeCharBtn" class="retroBtn">CHANGE CHARACTER</button>
  </div>
</div>

<script>
/* ---------- Query params & image list ---------- */
function getQueryParams() {
  const params = {};
  window.location.search.substring(1).split("&").forEach(pair => {
    const [key, value] = pair.split("=");
    if (key) params[key] = decodeURIComponent(value);
  });
  return params;
}
const params = getQueryParams();

const characterFiles = ['1.png','2.png','3.png','4.png','5.png','6.png','7.png','8.png'];
let playerImageSrc = params.img || characterFiles[0];

/* ---------- Canvas & images ---------- */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const backIcon = new Image(); backIcon.src = "back.png";
const settingsIcon = new Image(); settingsIcon.src = "setting.png";
const backBtn = { x: 15, y: 5, w: 50, h: 52 };
const settingsBtn = { x: canvas.width - 67, y: 1, w: 70, h: 70 };

const playerSprite = new Image(); playerSprite.src = playerImageSrc;
const aiCharacterFiles = characterFiles.filter(f => f !== playerImageSrc);
const npcSprites = aiCharacterFiles.map(src => { const img = new Image(); img.src = src; return img; });

const playerColumns = 4, playerRows = 4;
const npcColumns = 4, npcRows = 4;

/* Each image stores frameW/frameH on load so each sprite can have its own size */
let imagesLoaded = 0;
const totalImages = npcSprites.length + 1; // player + all NPC images

playerSprite.onload = () => {
  playerSprite.frameW = Math.floor(playerSprite.width / playerColumns);
  playerSprite.frameH = Math.floor(playerSprite.height / playerRows);
  imagesLoaded++; if (imagesLoaded >= totalImages) loop();
};
npcSprites.forEach(img => {
  img.onload = () => {
    img.frameW = Math.floor(img.width / npcColumns);
    img.frameH = Math.floor(img.height / npcRows);
    imagesLoaded++; if (imagesLoaded >= totalImages) loop();
  };
});

/* ---------- Game state & tuning ---------- */
let players = [];
const totalPlayers = 8;
const playArea = { x: 0, y: 150, width: canvas.width, height: canvas.height - 150 };

// speeds (tweakable)
const playerSpeed = 2.6;
const aiChaseSpeed = 2.4;   // tagger speed
const aiRunSpeed = 2.8;     // runner fleeing speed (slightly faster so fleeing looks real)
const aiWanderSpeed = 1.0;  // idle wander speed
const velocitySmoothing = 0.18; // interpolation factor for velocities

/* perception & behavior */
const threatRange = 240;     // when runners notice tagger
const separationDist = 60;   // how close AIs repel from each other
const separationStrength = 0.6; // influence of separation
const directionUpdateThreshold = 0.25; // minimum speed to change facing/animate

/* input */
const keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

/* ---------- Initialize game ---------- */
function initGame() {
  players = [];
  // shuffle AI sprites
  const shuffledAI = npcSprites.slice().sort(() => 0.5 - Math.random());

  for (let i = 0; i < totalPlayers; i++) {
    const sprite = (i === 0) ? playerSprite : shuffledAI[i - 1];
    players.push({
      x: Math.random() * (playArea.width - 100),
      y: playArea.y + Math.random() * (playArea.height - 100),
      w: 100, h: 100,
      isHuman: i === 0,
      sprite,
      frameX: 0, frameY: 0, frameCounter: 0,
      vx: 0, vy: 0,            // current velocity
      lastDir: 0,             // last facing (0=down,1=left,2=right,3=up)
      wanderTimer: 0,
      wanderDir: { x: 0, y: 0 },
      targetIndex: null,
      targetTimer: 0
    });
  }
  // random tagger
  players[Math.floor(Math.random() * players.length)].isTagger = true;
}
initGame();

/* ---------- Countdown ---------- */
let countdown = 3;
let gameStarted = false;
const countdownDiv = document.getElementById("countdown");
const countdownInterval = setInterval(() => {
  countdownDiv.textContent = countdown > 0 ? countdown : "GO!";
  if (countdown === 0) {
    clearInterval(countdownInterval);
    setTimeout(() => { countdownDiv.style.display = "none"; gameStarted = true; }, 1000);
  }
  countdown--;
}, 1000);

let gameOver = false;

/* ---------- Helpers ---------- */
function clampToPlayArea(p) {
  if (p.x < playArea.x) p.x = playArea.x;
  if (p.y < playArea.y) p.y = playArea.y;
  if (p.x > playArea.x + playArea.width - p.w) p.x = playArea.x + playArea.width - p.w;
  if (p.y > playArea.y + playArea.height - p.h) p.y = playArea.y + playArea.height - p.h;
}
function length(x, y) { return Math.hypot(x, y); }
function normalize(x, y) {
  const d = Math.hypot(x, y);
  return d === 0 ? { x: 0, y: 0 } : { x: x / d, y: y / d };
}
function centerOf(p) { return { x: p.x + p.w / 2, y: p.y + p.h / 2 }; }

/* ------ Animation helper: only animate when moving ------ */
function animate(p, maxFrames, isMoving) {
  if (isMoving) {
    p.frameCounter++;
    // faster if moving faster? here keep stable cadence
    if (p.frameCounter > 10) {
      p.frameX = (p.frameX + 1) % maxFrames;
      p.frameCounter = 0;
    }
  } else {
    p.frameX = 0;
    p.frameCounter = 0;
  }
}

/* ---------- Update loop ---------- */
function update() {
  if (!gameStarted || gameOver) return;

  // --- Human player (index 0) ---
  const p1 = players[0];
  let moved = false;
  // reset velocity for human each frame (direct control)
  p1.vx = 0; p1.vy = 0;
  if (keys["w"]) { p1.y -= playerSpeed; p1.frameY = 3; p1.lastDir = 3; moved = true; }
  if (keys["s"]) { p1.y += playerSpeed; p1.frameY = 0; p1.lastDir = 0; moved = true; }
  if (keys["a"]) { p1.x -= playerSpeed; p1.frameY = 1; p1.lastDir = 1; moved = true; }
  if (keys["d"]) { p1.x += playerSpeed; p1.frameY = 2; p1.lastDir = 2; moved = true; }
  if (moved) animate(p1, playerColumns, true);
  else { animate(p1, playerColumns, false); p1.frameY = p1.lastDir; }
  clampToPlayArea(p1);

  // collect taggers array for AI logic
  const taggers = players.filter(p => p.isTagger);

  // --- AI players ---
  for (let i = 1; i < players.length; i++) {
    const ai = players[i];

    // centers
    const aiC = centerOf(ai);

    // separation (avoid crowding)
    let sepX = 0, sepY = 0;
    let neighbors = 0;
    for (let j = 1; j < players.length; j++) {
      if (j === i) continue;
      const other = players[j];
      const oC = centerOf(other);
      const dx = aiC.x - oC.x, dy = aiC.y - oC.y;
      const d = Math.hypot(dx, dy);
      if (d > 0 && d < separationDist) {
        // push away stronger the closer they are
        sepX += (dx / d) * (separationDist - d);
        sepY += (dy / d) * (separationDist - d);
        neighbors++;
      }
    }
    if (neighbors > 0) {
      sepX = (sepX / neighbors) * separationStrength;
      sepY = (sepY / neighbors) * separationStrength;
    }

    // compute desired velocity
    let desiredVX = 0, desiredVY = 0;

    if (!ai.isTagger) {
      // Runner: find nearest tagger
      let nearest = null, minDist = Infinity;
      for (let t of taggers) {
        const tC = centerOf(t);
        const dx = aiC.x - tC.x, dy = aiC.y - tC.y;
        const dist = Math.hypot(dx, dy);
        if (dist < minDist) { minDist = dist; nearest = t; }
      }

      if (nearest && minDist < threatRange) {
        // flee from nearest tagger (smooth normalized vector away)
        const tC = centerOf(nearest);
        let dx = aiC.x - tC.x, dy = aiC.y - tC.y;
        const n = normalize(dx, dy);
        desiredVX = n.x * aiRunSpeed;
        desiredVY = n.y * aiRunSpeed;
      } else {
        // natural wander: keep direction for a while
        if (ai.wanderTimer <= 0) {
          const angle = Math.random() * Math.PI * 2;
          ai.wanderDir = { x: Math.cos(angle), y: Math.sin(angle) };
          ai.wanderTimer = 40 + Math.random() * 90; // hold 40-130 frames
        }
        desiredVX = ai.wanderDir.x * aiWanderSpeed;
        desiredVY = ai.wanderDir.y * aiWanderSpeed;
        ai.wanderTimer--;
      }
    } else {
      // Tagger: pick a target runner (prefer nearest but keep for a while)
      if (!ai.targetIndex || players[ai.targetIndex]?.isTagger || ai.targetTimer <= 0) {
        const runners = players.map((p, idx) => ({ p, idx })).filter(x => !x.p.isTagger);
        if (runners.length > 0) {
          // choose nearest runner now (more realistic), but add chance to pick random
          if (Math.random() < 0.25) {
            const r = runners[Math.floor(Math.random() * runners.length)];
            ai.targetIndex = r.idx;
          } else {
            // pick nearest runner
            let nearestIdx = runners[0].idx, nearestDist = Infinity;
            for (const r of runners) {
              const c = centerOf(r.p);
              const dx = c.x - aiC.x, dy = c.y - aiC.y;
              const dist = Math.hypot(dx, dy);
              if (dist < nearestDist) { nearestDist = dist; nearestIdx = r.idx; }
            }
            ai.targetIndex = nearestIdx;
          }
          ai.targetTimer = 40 + Math.random() * 120; // keep target some frames
        } else {
          ai.targetIndex = null;
          ai.targetTimer = 10;
        }
      } else {
        ai.targetTimer--;
      }

      const target = players[ai.targetIndex];
      if (target) {
        const tC = centerOf(target);
        let dx = tC.x - aiC.x, dy = tC.y - aiC.y;
        const n = normalize(dx, dy);
        desiredVX = n.x * aiChaseSpeed;
        desiredVY = n.y * aiChaseSpeed;
      }
    }

    // add separation influence
    desiredVX += sepX;
    desiredVY += sepY;

    // limit desired speed (so separation + wander doesn't exceed reasonable speed)
    const desiredMag = Math.hypot(desiredVX, desiredVY);
    const maxDesired = ai.isTagger ? aiChaseSpeed : (Math.hypot(desiredVX, desiredVY) > aiRunSpeed ? aiRunSpeed : aiWanderSpeed + 0.5);
    if (desiredMag > maxDesired && desiredMag > 0) {
      desiredVX = (desiredVX / desiredMag) * maxDesired;
      desiredVY = (desiredVY / desiredMag) * maxDesired;
    }

    // smooth velocity (steering) - this removes sudden jumps and jitter
    ai.vx += (desiredVX - ai.vx) * velocitySmoothing;
    ai.vy += (desiredVY - ai.vy) * velocitySmoothing;

    // update position using velocity
    ai.x += ai.vx;
    ai.y += ai.vy;

    // set facing: only change when velocity big enough
    const speedMag = Math.hypot(ai.vx, ai.vy);
    if (speedMag > directionUpdateThreshold) {
      if (Math.abs(ai.vx) > Math.abs(ai.vy)) {
        ai.frameY = ai.vx > 0 ? 2 : 1; // right : left
      } else {
        ai.frameY = ai.vy > 0 ? 0 : 3; // down : up
      }
      ai.lastDir = ai.frameY;
    } else {
      // idle keep last direction
      ai.frameY = ai.lastDir;
    }

    // animate only if actually moving
    animate(ai, npcColumns, speedMag > 0.2);

    clampToPlayArea(ai);
  } // end AI loop

  // --- Tagging collision (use center distance and a reasonable threshold) ---
  const taggersNow = players.filter(p => p.isTagger);
  for (const tagger of taggersNow) {
    for (const runner of players.filter(p => !p.isTagger)) {
      const tc = centerOf(tagger), rc = centerOf(runner);
      const d = Math.hypot(tc.x - rc.x, tc.y - rc.y);
      const threshold = (tagger.w + runner.w) * 0.28; // tuned collision threshold
      if (d < threshold) runner.isTagger = true;
    }
  }

  // Game over
  if (players.filter(p => !p.isTagger).length === 0) {
    gameOver = true;
    const modal = document.getElementById("gameOverModal");
    if (modal) modal.style.visibility = "visible";
  }
}

/* ---------- Draw ---------- */
function drawArrow(p, color) {
  const offset = 1; // almost touching the head
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(p.x + p.w / 2, p.y - offset);               // base of arrow just above head
  ctx.lineTo(p.x + p.w / 2 - 10, p.y - offset - 10);     // left tip
  ctx.lineTo(p.x + p.w / 2 + 10, p.y - offset - 10);     // right tip
  ctx.closePath();
  ctx.fill();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const p of players) {
    const img = p.sprite;
    const frameW = (img && img.frameW) ? img.frameW : Math.floor(img.width / playerColumns);
    const frameH = (img && img.frameH) ? img.frameH : Math.floor(img.height / playerRows);

    // safety fallback if image not loaded
    if (img && img.complete && frameW > 0 && frameH > 0) {
      ctx.drawImage(img, p.frameX * frameW, p.frameY * frameH, frameW, frameH, p.x, p.y, p.w, p.h);
    } else {
      // placeholder rectangle while image loads
      ctx.fillStyle = "#888";
      ctx.fillRect(p.x, p.y, p.w, p.h);
    }

    if (p.isTagger) drawArrow(p, "red");
  }

  if (backIcon.complete) ctx.drawImage(backIcon, backBtn.x, backBtn.y, backBtn.w, backBtn.h);
  if (settingsIcon.complete) ctx.drawImage(settingsIcon, settingsBtn.x, settingsBtn.y, settingsBtn.w, settingsBtn.h);
}

/* ---------- Main loop ---------- */
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

/* ---------- UI handlers ---------- */
document.getElementById("restartBtn").addEventListener("click", () => {
  const modal = document.getElementById("gameOverModal");
  if (modal) modal.style.visibility = "hidden";
  gameOver = false;
  initGame();
  // reset countdown and start again
  countdown = 3; gameStarted = false;
  if (countdownDiv) { countdownDiv.style.display = "block"; countdownDiv.textContent = countdown; }
  let newInterval = setInterval(() => {
    if (countdownDiv) countdownDiv.textContent = countdown > 0 ? countdown : "GO!";
    if (countdown === 0) {
      clearInterval(newInterval);
      setTimeout(() => { if (countdownDiv) countdownDiv.style.display = "none"; gameStarted = true; }, 800);
    }
    countdown--;
  }, 1000);
});

document.getElementById("quitBtn").addEventListener("click", () => { window.location.href = "index.html"; });
document.getElementById("changeCharBtn").addEventListener("click", () => { window.location.href = "characters.html"; });

canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  // Back button
  if (mx >= backBtn.x && mx <= backBtn.x + backBtn.w &&
      my >= backBtn.y && my <= backBtn.y + backBtn.h) {
    window.location.href = "characters.html";
  }

  // Settings button
  if (mx >= settingsBtn.x && mx <= settingsBtn.x + settingsBtn.w &&
      my >= settingsBtn.y && my <= settingsBtn.y + settingsBtn.h) {
    const s = document.getElementById("settingsModal");
    if (s) s.style.visibility = "visible";
  }
});

</script>

</body>
</html>
