<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mataya-Taya Game</title>
<link rel="icon" type="image/png" href="favicon.png">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
body {
  margin: 0; padding: 0;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
  font-family: 'Press Start 2P', cursive;
}

canvas {
  width: 65em;
  height: 40em;
  border: 4px solid #ffcc00;
  image-rendering: pixelated;
  background: url("place.jpg") no-repeat center center;
  background-size: cover;
  box-shadow: 0 0 10px #ffcc00;
  animation: glow 2s infinite alternate;
}

/* Retro pulsing glow animation */
@keyframes glow {
  0% { box-shadow: 0 0 10px #ffcc00; }
  100% { box-shadow: 0 0 30px #ff9900; }
}

#countdown {
  position: absolute;
  top: 40%;
  font-size: 48px;
  color: #ffcc00;
  text-shadow: 2px 2px 4px #000;
  animation: pop 1s ease infinite;
}

@keyframes pop {
  from { transform: scale(1); opacity: 1; }
  to { transform: scale(1.5); opacity: 0.6; }
}

.retroModal {
  position: fixed; top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  visibility: hidden;
  z-index: 10;
}

.retroContent {
  position: relative;
  background: #000;
  padding: 40px;
  border: 6px solid #ffcc00;
  text-align: center;
  box-shadow: 0 0 15px #ffcc00, inset 0 0 8px #663300;
  color: #ffcc00;
  font-family: 'Press Start 2P', cursive;
}

.retroContent::after {
  content: "";
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: repeating-linear-gradient(
    transparent 0px,
    rgba(255,255,255,0.05) 2px,
    transparent 4px
  );
  pointer-events: none;
}

.retroContent h1 {
  font-size: 28px;
  margin-bottom: 25px;
  color: #ff4444;
  text-shadow: 2px 2px #000, -2px -2px #000, 0 0 10px #ff0000;
}

.retroBtn {
  display: block;
  margin: 15px auto;
  padding: 15px 25px;
  font-size: 14px;
  background: #111;
  color: #ffcc00;
  border: 4px solid #ffcc00;
  cursor: pointer;
  border-radius: 0;
  text-transform: uppercase;
  font-family: 'Press Start 2P', cursive;
  transition: all 0.2s ease-in-out;
}

.retroBtn:hover {
  background: #ffcc00;
  color: #000;
  box-shadow: 0 0 10px #ffcc00;
}

</style>
</head>
<body>
<canvas id="gameCanvas" width="900" height="500"></canvas>
<div id="countdown"></div>

<!-- Game Over Modal -->
<div id="gameOverModal" class="retroModal">
  <div id="gameOverContent" class="retroContent">
    <h1>GAME OVER!</h1>
    <button id="restartBtn" class="retroBtn">PLAY AGAIN</button>
  </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="retroModal">
  <div class="retroContent">
    <h1>SETTINGS</h1>
    <button id="quitBtn" class="retroBtn">QUIT</button>
    <button id="changeCharBtn" class="retroBtn">CHANGE CHARACTER</button>
  </div>
</div>

<script>
/* ---------- Query params & image list ---------- */
function getQueryParams() {
  const params = {};
  window.location.search.substring(1).split("&").forEach(pair => {
    const [key, value] = pair.split("=");
    if (key) params[key] = decodeURIComponent(value);
  });
  return params;
}
const params = getQueryParams();

const characterFiles = ['1.png','2.png','3.png','4.png','5.png','6.png','7.png','8.png'];
let playerImageSrc = params.img || characterFiles[0];

/* ---------- Canvas & images ---------- */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const settingsIcon = new Image(); settingsIcon.src = "setting.png";
const settingsBtn = { x: canvas.width - 67, y: 1, w: 70, h: 70 };

const playerSprite = new Image(); playerSprite.src = playerImageSrc;
const aiCharacterFiles = characterFiles.filter(f => f !== playerImageSrc);
const npcSprites = aiCharacterFiles.map(src => { const img = new Image(); img.src = src; return img; });

const playerColumns = 4, playerRows = 4;
const npcColumns = 4, npcRows = 4;

/* Each image stores frameW/frameH on load so each sprite can have its own size */
let imagesLoaded = 0;
const totalImages = npcSprites.length + 1; // player + all NPC images

playerSprite.onload = () => {
  playerSprite.frameW = Math.floor(playerSprite.width / playerColumns);
  playerSprite.frameH = Math.floor(playerSprite.height / playerRows);
  imagesLoaded++; if (imagesLoaded >= totalImages) loop();
};
npcSprites.forEach(img => {
  img.onload = () => {
    img.frameW = Math.floor(img.width / npcColumns);
    img.frameH = Math.floor(img.height / npcRows);
    imagesLoaded++; if (imagesLoaded >= totalImages) loop();
  };
});

/* ---------- Game state & tuning ---------- */
let players = [];
const totalPlayers = 8;
const playArea = { x: 0, y: 150, width: canvas.width, height: canvas.height - 150 };

// speeds (tweakable)
const playerSpeed = 2.6;
const aiChaseSpeed = 2.4;
const aiRunSpeed = 2.8;
const aiWanderSpeed = 1.0;
const velocitySmoothing = 0.18;

/* perception & behavior */
const threatRange = 240;
const separationDist = 60;
const separationStrength = 0.6;
const directionUpdateThreshold = 0.25;

/* input */
const keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

/* ---------- Initialize game ---------- */
function initGame() {
  players = [];
  const shuffledAI = npcSprites.slice().sort(() => 0.5 - Math.random());

  for (let i = 0; i < totalPlayers; i++) {
    const sprite = (i === 0) ? playerSprite : shuffledAI[i - 1];
    players.push({
      x: Math.random() * (playArea.width - 100),
      y: playArea.y + Math.random() * (playArea.height - 100),
      w: 100, h: 100,
      isHuman: i === 0,
      sprite,
      frameX: 0, frameY: 0, frameCounter: 0,
      vx: 0, vy: 0,
      lastDir: 0,
      wanderTimer: 0,
      wanderDir: { x: 0, y: 0 },
      targetIndex: null,
      targetTimer: 0
    });
  }
  players[Math.floor(Math.random() * players.length)].isTagger = true;
}
initGame();

/* ---------- Countdown ---------- */
let countdown = 3;
let gameStarted = false;
const countdownDiv = document.getElementById("countdown");
const countdownInterval = setInterval(() => {
  countdownDiv.textContent = countdown > 0 ? countdown : "GO!";
  if (countdown === 0) {
    clearInterval(countdownInterval);
    setTimeout(() => { countdownDiv.style.display = "none"; gameStarted = true; }, 1000);
  }
  countdown--;
}, 1000);

let gameOver = false;

/* ---------- Helpers ---------- */
function clampToPlayArea(p) {
  if (p.x < playArea.x) p.x = playArea.x;
  if (p.y < playArea.y) p.y = playArea.y;
  if (p.x > playArea.x + playArea.width - p.w) p.x = playArea.x + playArea.width - p.w;
  if (p.y > playArea.y + playArea.height - p.h) p.y = playArea.y + playArea.height - p.h;
}
function length(x, y) { return Math.hypot(x, y); }
function normalize(x, y) {
  const d = Math.hypot(x, y);
  return d === 0 ? { x: 0, y: 0 } : { x: x / d, y: y / d };
}
function centerOf(p) { return { x: p.x + p.w / 2, y: p.y + p.h / 2 }; }

/* ------ Animation helper: only animate when moving ------ */
function animate(p, maxFrames, isMoving) {
  if (isMoving) {
    p.frameCounter++;
    if (p.frameCounter > 10) {
      p.frameX = (p.frameX + 1) % maxFrames;
      p.frameCounter = 0;
    }
  } else {
    p.frameX = 0;
    p.frameCounter = 0;
  }
}

/* ---------- Update loop ---------- */
function update() {
  if (!gameStarted || gameOver) return;

  const p1 = players[0];
  let moved = false;
  p1.vx = 0; p1.vy = 0;
  if (keys["w"]) { p1.y -= playerSpeed; p1.frameY = 3; p1.lastDir = 3; moved = true; }
  if (keys["s"]) { p1.y += playerSpeed; p1.frameY = 0; p1.lastDir = 0; moved = true; }
  if (keys["a"]) { p1.x -= playerSpeed; p1.frameY = 1; p1.lastDir = 1; moved = true; }
  if (keys["d"]) { p1.x += playerSpeed; p1.frameY = 2; p1.lastDir = 2; moved = true; }
  if (moved) animate(p1, playerColumns, true);
  else { animate(p1, playerColumns, false); p1.frameY = p1.lastDir; }
  clampToPlayArea(p1);

  const taggers = players.filter(p => p.isTagger);

  for (let i = 1; i < players.length; i++) {
    const ai = players[i];
    const aiC = centerOf(ai);

    let sepX = 0, sepY = 0;
    let neighbors = 0;
    for (let j = 1; j < players.length; j++) {
      if (j === i) continue;
      const other = players[j];
      const oC = centerOf(other);
      const dx = aiC.x - oC.x, dy = aiC.y - oC.y;
      const d = Math.hypot(dx, dy);
      if (d > 0 && d < separationDist) {
        sepX += (dx / d) * (separationDist - d);
        sepY += (dy / d) * (separationDist - d);
        neighbors++;
      }
    }
    if (neighbors > 0) { sepX = (sepX / neighbors) * separationStrength; sepY = (sepY / neighbors) * separationStrength; }

    let desiredVX = 0, desiredVY = 0;

    if (!ai.isTagger) {
      let nearest = null, minDist = Infinity;
      for (let t of taggers) {
        const tC = centerOf(t);
        const dx = aiC.x - tC.x, dy = aiC.y - tC.y;
        const dist = Math.hypot(dx, dy);
        if (dist < minDist) { minDist = dist; nearest = t; }
      }

      if (nearest && minDist < threatRange) {
        const tC = centerOf(nearest);
        let dx = aiC.x - tC.x, dy = aiC.y - tC.y;
        const n = normalize(dx, dy);
        desiredVX = n.x * aiRunSpeed;
        desiredVY = n.y * aiRunSpeed;
      } else {
        if (ai.wanderTimer <= 0) {
          const angle = Math.random() * Math.PI * 2;
          ai.wanderDir = { x: Math.cos(angle), y: Math.sin(angle) };
          ai.wanderTimer = 40 + Math.random() * 90;
        }
        desiredVX = ai.wanderDir.x * aiWanderSpeed;
        desiredVY = ai.wanderDir.y * aiWanderSpeed;
        ai.wanderTimer--;
      }
    } else {
      if (!ai.targetIndex || players[ai.targetIndex]?.isTagger || ai.targetTimer <= 0) {
        const runners = players.map((p, idx) => ({ p, idx })).filter(x => !x.p.isTagger);
        if (runners.length > 0) {
          if (Math.random() < 0.25) { const r = runners[Math.floor(Math.random() * runners.length)]; ai.targetIndex = r.idx; }
          else {
            let nearestIdx = runners[0].idx, nearestDist = Infinity;
            for (const r of runners) {
              const c = centerOf(r.p);
              const dx = c.x - aiC.x, dy = c.y - aiC.y;
              const dist = Math.hypot(dx, dy);
              if (dist < nearestDist) { nearestDist = dist; nearestIdx = r.idx; }
            }
            ai.targetIndex = nearestIdx;
          }
          ai.targetTimer = 40 + Math.random() * 120;
        } else { ai.targetIndex = null; ai.targetTimer = 10; }
      } else { ai.targetTimer--; }

      const target = players[ai.targetIndex];
      if (target) {
        const tC = centerOf(target);
        let dx = tC.x - aiC.x, dy = tC.y - aiC.y;
        const n = normalize(dx, dy);
        desiredVX = n.x * aiChaseSpeed;
        desiredVY = n.y * aiChaseSpeed;
      }
    }

    desiredVX += sepX;
    desiredVY += sepY;

    const desiredMag = Math.hypot(desiredVX, desiredVY);
    const maxDesired = ai.isTagger ? aiChaseSpeed : (Math.hypot(desiredVX, desiredVY) > aiRunSpeed ? aiRunSpeed : aiWanderSpeed + 0.5);
    if (desiredMag > maxDesired && desiredMag > 0) { desiredVX = (desiredVX / desiredMag) * maxDesired; desiredVY = (desiredVY / desiredMag) * maxDesired; }

    ai.vx += (desiredVX - ai.vx) * velocitySmoothing;
    ai.vy += (desiredVY - ai.vy) * velocitySmoothing;

    ai.x += ai.vx;
    ai.y += ai.vy;

    const speedMag = Math.hypot(ai.vx, ai.vy);
    if (speedMag > directionUpdateThreshold) {
      if (Math.abs(ai.vx) > Math.abs(ai.vy)) { ai.frameY = ai.vx > 0 ? 2 : 1; }
      else { ai.frameY = ai.vy > 0 ? 0 : 3; }
      ai.lastDir = ai.frameY;
    } else { ai.frameY = ai.lastDir; }

    animate(ai, npcColumns, speedMag > 0.2);
    clampToPlayArea(ai);
  }

  const taggersNow = players.filter(p => p.isTagger);
  for (const tagger of taggersNow) {
    for (const runner of players.filter(p => !p.isTagger)) {
      const tc = centerOf(tagger), rc = centerOf(runner);
      const d = Math.hypot(tc.x - rc.x, tc.y - rc.y);
      const threshold = (tagger.w + runner.w) * 0.28;
      if (d < threshold) runner.isTagger = true;
    }
  }

  if (players.filter(p => !p.isTagger).length === 0) {
    gameOver = true;
    const modal = document.getElementById("gameOverModal");
    if (modal) modal.style.visibility = "visible";
  }
}

/* ---------- Draw ---------- */
function drawArrow(p, color) {
  const offset = 1;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(p.x + p.w / 2, p.y - offset);
  ctx.lineTo(p.x + p.w / 2 - 10, p.y - offset - 10);
  ctx.lineTo(p.x + p.w / 2 + 10, p.y - offset - 10);
  ctx.closePath();
  ctx.fill();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const p of players) {
    const img = p.sprite;
    const frameW = (img && img.frameW) ? img.frameW : Math.floor(img.width / playerColumns);
    const frameH = (img && img.frameH) ? img.frameH : Math.floor(img.height / playerRows);

    if (img && img.complete && frameW > 0 && frameH > 0) {
      ctx.drawImage(img, p.frameX * frameW, p.frameY * frameH, frameW, frameH, p.x, p.y, p.w, p.h);
    } else {
      ctx.fillStyle = "#888";
      ctx.fillRect(p.x, p.y, p.w, p.h);
    }

    if (p.isTagger) drawArrow(p, "red");
  }

  if (settingsIcon.complete) ctx.drawImage(settingsIcon, settingsBtn.x, settingsBtn.y, settingsBtn.w, settingsBtn.h);
}

/* ---------- Main loop ---------- */
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

/* ---------- UI handlers ---------- */
document.getElementById("restartBtn").addEventListener("click", () => {
  const modal = document.getElementById("gameOverModal");
  if (modal) modal.style.visibility = "hidden";
  gameOver = false;
  initGame();
  countdown = 3; gameStarted = false;
  if (countdownDiv) { countdownDiv.style.display = "block"; countdownDiv.textContent = countdown; }
  let newInterval = setInterval(() => {
    if (countdownDiv) countdownDiv.textContent = countdown > 0 ? countdown : "GO!";
    if (countdown === 0) {
      clearInterval(newInterval);
      setTimeout(() => { if (countdownDiv) countdownDiv.style.display = "none"; gameStarted = true; }, 800);
    }
    countdown--;
  }, 1000);
});

document.getElementById("quitBtn").addEventListener("click", () => { window.location.href = "index.html"; });
document.getElementById("changeCharBtn").addEventListener("click", () => { window.location.href = "characters.html"; });

canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  // Settings button
  if (mx >= settingsBtn.x && mx <= settingsBtn.x + settingsBtn.w &&
      my >= settingsBtn.y && my <= settingsBtn.y + settingsBtn.h) {
    const s = document.getElementById("settingsModal");
    if (s) s.style.visibility = "visible";
  }
});
</script>

</body>
</html>
